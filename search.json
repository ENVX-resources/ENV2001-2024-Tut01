[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorial 02",
    "section": "",
    "text": "Welcome üëã\nWelcome to Tutorial 2. In this tutorial we will show you how to:",
    "crumbs": [
      "Welcome üëã"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Tutorial 02",
    "section": "",
    "text": "Take a random sample from a finite population; and\ntake a random sample from an infinite population.",
    "crumbs": [
      "Welcome üëã"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Tutorial 02",
    "section": "Getting started",
    "text": "Getting started\n\nThese tutorials are designed to be comprehensive yet accessible. I recommend following along and grasping the statistical concepts as your top priority.\nYou will need to create your own Quarto (recommended) or R Markdown document to complete the exercises. In RStudio, go to\n\nFile -&gt; New File -&gt; Quarto Document... or\nFile -&gt; New File -&gt; R Markdown... and follow the intuitive prompts.\n\nFor those of you who are interested in furthering your data science skills and are keen to learn more, I have included optional sections.These techniques are not necessary for you to get through ENVX2001 ‚Äì we do not cover code in the exams. Nevertheless these skills come handy in report writng and data analysis and can be a great addition to your projects.\nIf you have any suggestions for improvement, please let me know! Send me an email (you can find my details on Canvas).\n\nClick on the topics on the left to get started.",
    "crumbs": [
      "Welcome üëã"
    ]
  },
  {
    "objectID": "finite.html",
    "href": "finite.html",
    "title": "1¬† Sampling finite populations",
    "section": "",
    "text": "1.1 Finite populations\nImagine a hypothetical situation where we know there are 100 farms in a catchment, and we wish to survey 10 of them about their management practices. To ensure unbiased results, the 10 farms should be randomly selected.\nR can do this for us quite easily.\nBelow is the full code to randomly select 10 farms from the 100 in the catchment. We will break it down step by step.\nset.seed(1038)\nfarms &lt;- 1:100\nsample(x = farms, size = 100)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Sampling finite populations</span>"
    ]
  },
  {
    "objectID": "finite.html#finite-populations",
    "href": "finite.html#finite-populations",
    "title": "1¬† Sampling finite populations",
    "section": "",
    "text": "1.1.1 Random, but reproducible\n\nset.seed(1038)\n\nThe set.seed() function is used to ‚Äúfix the seed‚Äù of the random number generator. This is useful when you want to ensure that the random numbers generated are the same each time you run the code, which is useful for reproducibility. We don‚Äôt want to randomly select 10 farms, and then run the code again and get a different set of 10 farms!\nThe number in the brackets can be any number you choose1.\n1¬†It is good practice to be as unbiased as possible when picking a number for set.seed(). A good choice is the 4 digits for the current time of the day.\n\n1.1.2 Identifying the population\n\nfarms &lt;- 1:100\n\nIf there are 100 farms, then we need to be able to select from them. This ensures that each farm is unique so that we can perform random sampling without replacement (i.e.¬†we should not be sampling the same farm twice).\nThe colon operator (:) creates a sequence of numbers from the first number to the second number. For 100 farms we can create a sequence of numbers from 1 to 100 easily using this operator, and assign it to the object farms.\n\n\n1.1.3 Simple random sampling\n\nsites &lt;- sample(x = farms, size = 10)\n\nThe sample() function is a base R function ‚Äì part of the core R language ‚Äì and is used to take a random sample of a specified size from a set of values.\n\n\nNotice that no result is printed to the console when you assign (&lt;-) something to and object like sites. This is because R is not being asked to print anything, and so unless the function itself prints something, nothing will be presented to you. You can print the result by typing sites again in a new line, which instructs R to print the value of sites.\nTo use the sample() function, you need to specify the following arguments:\n\nx: the set of values from which to sample. In this case, the set of farms.\nsize: the number of values to sample. In this case, 10 farms.\n\nThe sample() function returns a vector of the randomly selected farms, which we have assigned to the object sites.\nWe now have our random sample of 10 farms from the 100 in the catchment.\n\nsites\n\n [1] 92 27 78 54 48 44 61 66  4 83\n\n\n\n\nIf you have set the same seed as we have, you should get the same results, which makes your experimental design reproducible.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Sampling finite populations</span>"
    ]
  },
  {
    "objectID": "finite.html#bonus",
    "href": "finite.html#bonus",
    "title": "1¬† Sampling finite populations",
    "section": "1.2 Bonus",
    "text": "1.2 Bonus\nA tidyverse approach to the same problem would be to use the dplyr package to create a sequence of numbers from 1 to 100, and then use the sample_n() function from the dplyr package to take a random sample of 10 farms from the 100 in the catchment.\nThe action can be performed using pipes (|&gt;) to pass the result of one function to the next function, which makes the code easier to read and understand (this is an opinion shared by many).\n\npipe approachNested approachStepped approach\n\n\n\nlibrary(dplyr)\nsites &lt;-\n    tibble(farm = 1:100) |&gt; # create a tibble of 100 farms, and pass it to the next function\n    sample_n(10) # take a random sample of 10 farms\n\n\n\n\nlibrary(dplyr)\nsites &lt;- sample_n(tibble(farm = 1:100), 10)\n\n\n\n\nlibrary(dplyr)\n\nfarms &lt;- tibble(farm = 1:100)\nsites &lt;- sample_n(farms, 10)\n\n\n\n\n\n\nPiping is a powerful feature of the tidyverse in R and is common in other programming languages. Here, the |&gt; operator is used to pass the result of the tibble() function to the sample_n() function.\nWithout piping, we would either have to nest the functions, or assign the result of the first function to an object and then pass that object in a stepped approach, which generates redundant ‚Äúintermediate‚Äù objects before the final result is obtained.\nThe tibble() function is used to create a tibble, which is a modern version of a data frame. The sample_n() function is used to take a random sample of a specified size from a tibble.\n\nsites\n\n# A tibble: 10 √ó 1\n    farm\n   &lt;int&gt;\n 1    14\n 2    41\n 3    96\n 4    73\n 5    25\n 6    88\n 7    40\n 8    32\n 9    39\n10    21\n\n\nUnlike sample(), sample_n() returns a tibble object which shows data in a column rather than row. It may look clutered with a single variable but it is useful for working with data in the tidyverse, especially when you have multiple variables.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Sampling finite populations</span>"
    ]
  },
  {
    "objectID": "finite.html#practice",
    "href": "finite.html#practice",
    "title": "1¬† Sampling finite populations",
    "section": "1.3 Practice",
    "text": "1.3 Practice\nUse this section to practice taking random samples from finite populations. Code is provided, but hidden by default for you to make comparisons with your own. Click on the ‚ÄúShow the code‚Äù button to reveal the code.\n\nCreate a random sample of 15 cats from a population of 300 cats.\n\n\nbase Rdplyr approach\n\n\n\n\nShow the code\nset.seed(1202)\ncats &lt;- 1:300\nsubjects &lt;- sample(x = cats, size = 15)\n\n\n\n\n\n\nShow the code\nset.seed(1202)\nsubjects &lt;-\n    tibble(cat = 1:300) |&gt;\n    sample_n(15)\n\n\n\n\n\n\nCreate a random sample of 20 trees from a population of 500 trees.\n\n\nbase Rdplyr approach\n\n\n\n\nShow the code\nset.seed(1204)\ntrees &lt;- 1:500\nsubjects &lt;- sample(x = trees, size = 20)\n\n\n\n\n\n\nShow the code\nset.seed(1204)\nsubjects &lt;-\n    tibble(tree = 1:500) |&gt;\n    sample_n(20)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Sampling finite populations</span>"
    ]
  },
  {
    "objectID": "finite.html#next",
    "href": "finite.html#next",
    "title": "1¬† Sampling finite populations",
    "section": "1.4 Next",
    "text": "1.4 Next\nWhen you are ready, go to the next section to learn about sampling from infinite populations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Sampling finite populations</span>"
    ]
  },
  {
    "objectID": "infinite.html",
    "href": "infinite.html",
    "title": "2¬† Sampling infinite populations",
    "section": "",
    "text": "2.1 Infinite populations\nWith infinite populations, we deal with continuous variables which the function sample() cannot handle as it is designed to work with discrete variables only (whole numbers).",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Sampling infinite populations</span>"
    ]
  },
  {
    "objectID": "infinite.html#infinite-populations",
    "href": "infinite.html#infinite-populations",
    "title": "2¬† Sampling infinite populations",
    "section": "",
    "text": "2.1.1 Uniform distribution\nImagine we are interested in estimating the mean of a measurement, spatially, across a study area. In this case we need to randomly choose a spatial location which is defined by a spatial coordinate, x and y, and the chance of choosing any location is equal. This is a uniform distribution.\nAssuming a hypothetical study site 100m wide and 100m long where we wish to choose 10 random locations, then we may use the technique below to randomly select 10 locations based on x and y coordinates:\n\nset.seed(1209)\nxcoord &lt;- runif(n = 10, min = 0, max = 100)\nycoord &lt;- runif(n = 10, min = 0, max = 100)\n\nsites_xy &lt;- data.frame(xcoord, ycoord)\n\nThe runif function generates random numbers from a uniform distribution, which means that each number is equally likely to be chosen.\nThe 3 main arguments (inputs) are:\n\nx: the number of samples,\nmin: the minimum value we want in our random numbers\nmax: the minimum value we want in our random numbers\n\n\n\nUse ?runif to learn more about the runif() function.\nAs we can see, with two variables (x and y) we now use a data frame to store the information.\n\nsites_xy\n\n     xcoord    ycoord\n1  29.14598  5.810736\n2  48.35873 86.962687\n3  99.50902 60.200064\n4  17.75811 83.790473\n5  24.95613 81.485062\n6  20.90561 48.077787\n7  91.04788  6.096274\n8  30.24953  9.560046\n9  83.37310 36.851027\n10 85.06082 80.864236\n\n\n\n\n2.1.2 Exploring the data frame\nViewing the data frame can eventually become clunky, and this is even more so when we have more than 2 variables. Use the head() or str() functions to view the first few rows or the structure of the data frame, respectively.\n\nhead(sites_xy)\n\n    xcoord    ycoord\n1 29.14598  5.810736\n2 48.35873 86.962687\n3 99.50902 60.200064\n4 17.75811 83.790473\n5 24.95613 81.485062\n6 20.90561 48.077787\n\n\nUsing head() shortens the output to the first few rows, which helps a lot when the data frame is large (you don‚Äôt want to see all the rows at once since the maximum number of rows that can be displayed is 1000).\n\nstr(sites_xy)\n\n'data.frame':   10 obs. of  2 variables:\n $ xcoord: num  29.1 48.4 99.5 17.8 25 ...\n $ ycoord: num  5.81 86.96 60.2 83.79 81.49 ...\n\n\nThe str() function provides a concise summary of the structure of the data frame. It tells us the number of observations and variables, and the type of each variable. This function is probably the most used exploratory function in R.\nBonus: The glimpse() function from the dplyr package is a more modern and user-friendly version of str(), and works with both data frames and tibbles. It is especially useful when working with large data frames.\n\ndplyr::glimpse(sites_xy)\n\nRows: 10\nColumns: 2\n$ xcoord &lt;dbl&gt; 29.14598, 48.35873, 99.50902, 17.75811, 24.95613, 20.90561, 91.‚Ä¶\n$ ycoord &lt;dbl&gt; 5.810736, 86.962687, 60.200064, 83.790473, 81.485062, 48.077787‚Ä¶\n\n\n\n\nNotice the :: operator in the glimpse() function. This is used to access functions from a package without loading the entire package. We basically interpret this as: ‚Äúuse the glimpse() function from the dplyr package.‚Äù Note that the package must be installed for this to work and you also need to know in advance that the function glimpse() is available in the package dplyr.\n\n\n2.1.3 Visualising the data\nAfter generating the random points, it is always a good idea to visualise them to see if there are issues with the random points. This is especially important when working with spatial data ‚Äì in rare cases, the random points may cluster in one area, which is not ideal for a random sample.\nWe can use the plot() function to visualise the points, or we can use the ggplot2 package. With enough effort, both methods can produce the same plot, but ggplot2 is more flexible as it follows the grammar of graphics1. My recommendation is that you learn ggplot2 as it is more powerful and flexible. A good idea in this case is to plot in base R first, and then asking GenAI to plot the same plot using ggplot2.\n1¬†The grammar of graphics is a system for understanding and building graphs by combining components, such as data, scales, and layers, in a consistent and structured way.\nBase R plotggplot2\n\n\n\nplot(sites_xy,\n    pch = 19,\n    col = \"blue\",\n    main = \"Random points\",\n    xlab = \"X coordinate\",\n    ylab = \"Y coordinate\"\n)\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\n\nggplot(\n    data = sites_xy,\n    aes(x = xcoord, y = ycoord)\n) +\n    geom_point() +\n    labs(\n        title = \"Random points\",\n        x = \"X coordinate\",\n        y = \"Y coordinate\"\n    ) +\n    theme_bw()\n\n\n\n\n\n\n\n\n\n\n\nClearly, one issue is that not all study areas are rectangles! Rather, they are quite often irregular. This artificial dataset is just to illustrate the concept of sampling infinitely, rather than be practically useful. The analysis of spatial data is not in the scope of this unit.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Sampling infinite populations</span>"
    ]
  },
  {
    "objectID": "infinite.html#practice",
    "href": "infinite.html#practice",
    "title": "2¬† Sampling infinite populations",
    "section": "2.2 Practice",
    "text": "2.2 Practice\nUse this section to practice taking random samples from finite populations. Code is provided, but hidden by default for you to make comparisons with your own. Click on the ‚ÄúShow the code‚Äù button to reveal the code.\n\nGenerate 20 random points within a 100m x 100m study area.\n\n\n\nShow the code\nset.seed(1242)\nxcoord &lt;- runif(n = 20, min = 0, max = 100)\nycoord &lt;- runif(n = 20, min = 0, max = 100)\nsites &lt;- data.frame(xcoord, ycoord)\n\n\n\nNow this combines sample() and runif() functions. Use runif() to generate 100 data points between 10 and 20, and then use sample() to sample 20 of these points.\n\n\n\nShow the code\nset.seed(1242)\ndata &lt;- runif(n = 100, min = 10, max = 20)\nsampled_data &lt;- sample(data, size = 20)\n\n\n\nUse ggplot2 to plot a histogram of the sampled data generated in the previous step.\n\n\n\nShow the code\nlibrary(ggplot2)\nggplot(\n    data = data.frame(data = sampled_data),\n    aes(x = data)\n) +\n    geom_histogram(\n        binwidth = 0.5,\n        color = \"black\"\n    ) +\n    labs(\n        title = \"Histogram of sampled data\",\n        x = \"Value\",\n        y = \"Frequency\"\n    ) +\n    theme_bw()",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Sampling infinite populations</span>"
    ]
  }
]